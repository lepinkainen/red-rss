package main

import (
	"fmt"
	"log/slog"
	"os"
	"strings"
	"time"

	"github.com/gorilla/feeds"
)

// FeedGenerator handles RSS/Atom feed generation
type FeedGenerator struct {
	ogFetcher *OpenGraphFetcher
}

// NewFeedGenerator creates a new feed generator with OpenGraph fetcher
func NewFeedGenerator(ogFetcher *OpenGraphFetcher) *FeedGenerator {
	return &FeedGenerator{
		ogFetcher: ogFetcher,
	}
}

// GenerateFeed creates an RSS or Atom feed from the filtered Reddit posts
func (fg *FeedGenerator) GenerateFeed(posts []RedditPost, feedType string) (*feeds.Feed, error) {
	if feedType != "rss" && feedType != "atom" {
		return nil, fmt.Errorf("unsupported feed type: %s", feedType)
	}

	now := time.Now()
	feed := &feeds.Feed{
		Title:       "My Reddit Homepage Feed",
		Link:        &feeds.Link{Href: "https://www.reddit.com/"},
		Description: "Filtered Reddit homepage posts generated by GoRedditFeedGenerator",
		Author:      &feeds.Author{Name: "GoRedditFeedGenerator"},
		Created:     now,
		Updated:     now,
	}

	// Collect URLs for concurrent OpenGraph fetching
	urls := make([]string, 0, len(posts))
	for _, post := range posts {
		if post.Data.URL != "" {
			urls = append(urls, post.Data.URL)
		}
	}

	// Fetch OpenGraph data concurrently
	var ogData map[string]*OpenGraphData
	if fg.ogFetcher != nil {
		ogData = fg.ogFetcher.FetchConcurrentOpenGraph(urls)
	}

	// Create feed items
	for _, post := range posts {
		item := fg.createFeedItem(post, ogData)
		feed.Items = append(feed.Items, item)
	}

	slog.Info("Generated feed", "type", feedType, "items", len(feed.Items))
	return feed, nil
}

// createFeedItem creates a feed item from a Reddit post
func (fg *FeedGenerator) createFeedItem(post RedditPost, ogData map[string]*OpenGraphData) *feeds.Item {
	// Build base description with Reddit metadata
	description := fmt.Sprintf("Score: %d, Comments: %d, Subreddit: r/%s",
		post.Data.Score, post.Data.NumComments, post.Data.Subreddit)

	// Add OpenGraph data if available
	if ogData != nil {
		if og, exists := ogData[post.Data.URL]; exists && og != nil {
			description += fg.formatOpenGraphPreview(og)
		}
	}

	// Note: Categories would be added here if supported by gorilla/feeds

	item := &feeds.Item{
		Title:       post.Data.Title,
		Link:        &feeds.Link{Href: post.Data.URL},
		Description: description,
		Author:      &feeds.Author{Name: post.Data.Author},
		Created:     time.Unix(int64(post.Data.CreatedUTC), 0),
		Id:          fmt.Sprintf("https://www.reddit.com%s", post.Data.Permalink),
		// Note: Categories not supported by gorilla/feeds
	}

	return item
}

// formatOpenGraphPreview formats OpenGraph data for display in feed
func (fg *FeedGenerator) formatOpenGraphPreview(og *OpenGraphData) string {
	if og.Title == "" && og.Description == "" {
		return ""
	}

	var preview strings.Builder
	preview.WriteString("\n\nðŸ”— Link Preview:")

	if og.Title != "" {
		preview.WriteString(fmt.Sprintf("\nTitle: %s", og.Title))
	}

	if og.Description != "" {
		preview.WriteString(fmt.Sprintf("\nDescription: %s", og.Description))
	}

	if og.SiteName != "" {
		preview.WriteString(fmt.Sprintf("\nSite: %s", og.SiteName))
	}

	return preview.String()
}

// SaveFeedToFile saves the generated feed to a specified file
func (fg *FeedGenerator) SaveFeedToFile(feed *feeds.Feed, feedType, outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	switch feedType {
	case "rss":
		err = feed.WriteRss(file)
	case "atom":
		err = feed.WriteAtom(file)
	default:
		return fmt.Errorf("unsupported feed type: %s", feedType)
	}

	if err != nil {
		return fmt.Errorf("failed to write %s feed: %w", feedType, err)
	}

	slog.Info("Feed saved successfully", "type", feedType, "path", outputPath)
	return nil
}

// ValidateFeed validates the generated feed structure
func (fg *FeedGenerator) ValidateFeed(feed *feeds.Feed) error {
	if feed == nil {
		return fmt.Errorf("feed is nil")
	}

	if feed.Title == "" {
		return fmt.Errorf("feed title is empty")
	}

	if feed.Link == nil || feed.Link.Href == "" {
		return fmt.Errorf("feed link is empty")
	}

	if feed.Description == "" {
		return fmt.Errorf("feed description is empty")
	}

	if len(feed.Items) == 0 {
		return fmt.Errorf("feed has no items")
	}

	// Validate feed items
	for i, item := range feed.Items {
		if err := fg.validateFeedItem(item); err != nil {
			return fmt.Errorf("item %d validation failed: %w", i, err)
		}
	}

	return nil
}

// validateFeedItem validates individual feed items
func (fg *FeedGenerator) validateFeedItem(item *feeds.Item) error {
	if item.Title == "" {
		return fmt.Errorf("item title is empty")
	}

	if item.Link == nil || item.Link.Href == "" {
		return fmt.Errorf("item link is empty")
	}

	if item.Id == "" {
		return fmt.Errorf("item ID is empty")
	}

	return nil
}

// GetFeedMetadata returns metadata about the generated feed
func (fg *FeedGenerator) GetFeedMetadata(feed *feeds.Feed) *FeedMetadata {
	if feed == nil {
		return nil
	}

	metadata := &FeedMetadata{
		Title:       feed.Title,
		Description: feed.Description,
		ItemCount:   len(feed.Items),
		Created:     feed.Created,
		Updated:     feed.Updated,
	}

	if len(feed.Items) > 0 {
		// Find oldest and newest items
		oldest := feed.Items[0].Created
		newest := feed.Items[0].Created

		for _, item := range feed.Items {
			if item.Created.Before(oldest) {
				oldest = item.Created
			}
			if item.Created.After(newest) {
				newest = item.Created
			}
		}

		metadata.OldestItem = oldest
		metadata.NewestItem = newest
	}

	return metadata
}

// FeedMetadata contains metadata about a generated feed
type FeedMetadata struct {
	Title       string
	Description string
	ItemCount   int
	Created     time.Time
	Updated     time.Time
	OldestItem  time.Time
	NewestItem  time.Time
}

// CreateCustomAtomFeed creates a custom Atom feed structure (similar to HN tool)
func (fg *FeedGenerator) CreateCustomAtomFeed(posts []RedditPost) (string, error) {
	now := time.Now()

	var atom strings.Builder
	atom.WriteString(`<?xml version="1.0" encoding="UTF-8"?>`)
	atom.WriteString(`<feed xmlns="http://www.w3.org/2005/Atom">`)
	atom.WriteString(`<title>My Reddit Homepage Feed</title>`)
	atom.WriteString(`<link href="https://www.reddit.com/"/>`)
	atom.WriteString(`<id>https://www.reddit.com/</id>`)
	atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, now.Format(time.RFC3339)))
	atom.WriteString(`<author><name>GoRedditFeedGenerator</name></author>`)

	for _, post := range posts {
		atom.WriteString(`<entry>`)
		atom.WriteString(fmt.Sprintf(`<title>%s</title>`, escapeXML(post.Data.Title)))
		atom.WriteString(fmt.Sprintf(`<link href="%s"/>`, escapeXML(post.Data.URL)))
		atom.WriteString(fmt.Sprintf(`<id>https://www.reddit.com%s</id>`, escapeXML(post.Data.Permalink)))
		atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, time.Unix(int64(post.Data.CreatedUTC), 0).Format(time.RFC3339)))
		atom.WriteString(fmt.Sprintf(`<author><name>%s</name></author>`, escapeXML(post.Data.Author)))

		// Add categories
		atom.WriteString(fmt.Sprintf(`<category term="r/%s"/>`, escapeXML(post.Data.Subreddit)))

		// Add summary
		summary := fmt.Sprintf("Score: %d, Comments: %d, Subreddit: r/%s",
			post.Data.Score, post.Data.NumComments, post.Data.Subreddit)
		atom.WriteString(fmt.Sprintf(`<summary>%s</summary>`, escapeXML(summary)))

		atom.WriteString(`</entry>`)
	}

	atom.WriteString(`</feed>`)
	return atom.String(), nil
}

// escapeXML escapes XML special characters
func escapeXML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	s = strings.ReplaceAll(s, "'", "&apos;")
	return s
}
