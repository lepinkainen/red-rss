package main

import (
	"fmt"
	"log/slog"
	"os"
	"strings"
	"time"

	"github.com/gorilla/feeds"
)

// FeedGenerator handles RSS/Atom feed generation
type FeedGenerator struct {
	ogFetcher *OpenGraphFetcher
}

// NewFeedGenerator creates a new feed generator with OpenGraph fetcher
func NewFeedGenerator(ogFetcher *OpenGraphFetcher) *FeedGenerator {
	return &FeedGenerator{
		ogFetcher: ogFetcher,
	}
}

// GenerateFeed creates an RSS or Atom feed from the filtered Reddit posts
func (fg *FeedGenerator) GenerateFeed(posts []RedditPost, feedType string) (*feeds.Feed, error) {
	if feedType != "rss" && feedType != "atom" {
		return nil, fmt.Errorf("unsupported feed type: %s", feedType)
	}

	now := time.Now()
	feed := &feeds.Feed{
		Title:       "My Reddit Homepage Feed",
		Link:        &feeds.Link{Href: "https://www.reddit.com/"},
		Description: "Filtered Reddit homepage posts generated by GoRedditFeedGenerator",
		Author:      &feeds.Author{Name: "GoRedditFeedGenerator"},
		Created:     now,
		Updated:     now,
	}

	// Collect URLs for concurrent OpenGraph fetching
	urls := make([]string, 0, len(posts))
	for _, post := range posts {
		if post.Data.URL != "" {
			urls = append(urls, post.Data.URL)
			slog.Debug("Collected URL for OpenGraph", "url", post.Data.URL, "title", post.Data.Title)
		}
	}

	// Fetch OpenGraph data concurrently
	var ogData map[string]*OpenGraphData
	if fg.ogFetcher != nil {
		slog.Info("Fetching OpenGraph data", "url_count", len(urls))
		ogData = fg.ogFetcher.FetchConcurrentOpenGraph(urls)
		slog.Info("OpenGraph fetch completed", "results_count", len(ogData))
		for url, og := range ogData {
			if og != nil {
				slog.Debug("OpenGraph data fetched", "url", url, "title", og.Title, "has_description", og.Description != "")
			}
		}
	}

	// Create feed items
	for _, post := range posts {
		item := fg.createFeedItem(post, ogData)
		feed.Items = append(feed.Items, item)
	}

	slog.Info("Generated feed", "type", feedType, "items", len(feed.Items))
	return feed, nil
}

// createFeedItem creates a feed item from a Reddit post
func (fg *FeedGenerator) createFeedItem(post RedditPost, ogData map[string]*OpenGraphData) *feeds.Item {
	// Build base description with Reddit metadata
	description := fmt.Sprintf("Score: %d, Comments: %d, Subreddit: r/%s",
		post.Data.Score, post.Data.NumComments, post.Data.Subreddit)

	// Add OpenGraph data if available
	if ogData != nil {
		if og, exists := ogData[post.Data.URL]; exists && og != nil {
			slog.Debug("Adding OpenGraph preview", "url", post.Data.URL, "title", og.Title)
			description += fg.formatOpenGraphPreview(og)
		} else {
			slog.Debug("No OpenGraph data found", "url", post.Data.URL, "exists", exists)
		}
	} else {
		slog.Debug("No OpenGraph data map available", "url", post.Data.URL)
	}

	// Note: Categories would be added here if supported by gorilla/feeds

	item := &feeds.Item{
		Title:       post.Data.Title,
		Link:        &feeds.Link{Href: post.Data.URL},
		Description: description,
		Author:      &feeds.Author{Name: post.Data.Author},
		Created:     time.Unix(int64(post.Data.CreatedUTC), 0),
		Id:          fmt.Sprintf("https://www.reddit.com%s", post.Data.Permalink),
		// Note: Categories not supported by gorilla/feeds
	}

	return item
}

// formatOpenGraphPreview formats OpenGraph data for display in feed
func (fg *FeedGenerator) formatOpenGraphPreview(og *OpenGraphData) string {
	if og.Title == "" && og.Description == "" {
		return ""
	}

	var preview strings.Builder
	preview.WriteString("\n\nðŸ”— Link Preview:")

	if og.Title != "" {
		preview.WriteString(fmt.Sprintf("\nTitle: %s", og.Title))
	}

	if og.Description != "" {
		preview.WriteString(fmt.Sprintf("\nDescription: %s", og.Description))
	}

	if og.SiteName != "" {
		preview.WriteString(fmt.Sprintf("\nSite: %s", og.SiteName))
	}

	return preview.String()
}

// SaveFeedToFile saves the generated feed to a specified file
func (fg *FeedGenerator) SaveFeedToFile(feed *feeds.Feed, feedType, outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	switch feedType {
	case "rss":
		err = feed.WriteRss(file)
	case "atom":
		err = feed.WriteAtom(file)
	default:
		return fmt.Errorf("unsupported feed type: %s", feedType)
	}

	if err != nil {
		return fmt.Errorf("failed to write %s feed: %w", feedType, err)
	}

	slog.Info("Feed saved successfully", "type", feedType, "path", outputPath)
	return nil
}

// SaveCustomAtomFeedToFile saves a custom enhanced Atom feed to a specified file
func (fg *FeedGenerator) SaveCustomAtomFeedToFile(posts []RedditPost, outputPath string) error {
	atomContent, err := fg.CreateCustomAtomFeed(posts)
	if err != nil {
		return fmt.Errorf("failed to create custom atom feed: %w", err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer file.Close()

	_, err = file.WriteString(atomContent)
	if err != nil {
		return fmt.Errorf("failed to write custom atom feed: %w", err)
	}

	slog.Info("Enhanced Atom feed saved successfully", "path", outputPath)
	return nil
}

// ValidateFeed validates the generated feed structure
func (fg *FeedGenerator) ValidateFeed(feed *feeds.Feed) error {
	if feed == nil {
		return fmt.Errorf("feed is nil")
	}

	if feed.Title == "" {
		return fmt.Errorf("feed title is empty")
	}

	if feed.Link == nil || feed.Link.Href == "" {
		return fmt.Errorf("feed link is empty")
	}

	if feed.Description == "" {
		return fmt.Errorf("feed description is empty")
	}

	if len(feed.Items) == 0 {
		return fmt.Errorf("feed has no items")
	}

	// Validate feed items
	for i, item := range feed.Items {
		if err := fg.validateFeedItem(item); err != nil {
			return fmt.Errorf("item %d validation failed: %w", i, err)
		}
	}

	return nil
}

// validateFeedItem validates individual feed items
func (fg *FeedGenerator) validateFeedItem(item *feeds.Item) error {
	if item.Title == "" {
		return fmt.Errorf("item title is empty")
	}

	if item.Link == nil || item.Link.Href == "" {
		return fmt.Errorf("item link is empty")
	}

	if item.Id == "" {
		return fmt.Errorf("item ID is empty")
	}

	return nil
}

// GetFeedMetadata returns metadata about the generated feed
func (fg *FeedGenerator) GetFeedMetadata(feed *feeds.Feed) *FeedMetadata {
	if feed == nil {
		return nil
	}

	metadata := &FeedMetadata{
		Title:       feed.Title,
		Description: feed.Description,
		ItemCount:   len(feed.Items),
		Created:     feed.Created,
		Updated:     feed.Updated,
	}

	if len(feed.Items) > 0 {
		// Find oldest and newest items
		oldest := feed.Items[0].Created
		newest := feed.Items[0].Created

		for _, item := range feed.Items {
			if item.Created.Before(oldest) {
				oldest = item.Created
			}
			if item.Created.After(newest) {
				newest = item.Created
			}
		}

		metadata.OldestItem = oldest
		metadata.NewestItem = newest
	}

	return metadata
}

// FeedMetadata contains metadata about a generated feed
type FeedMetadata struct {
	Title       string
	Description string
	ItemCount   int
	Created     time.Time
	Updated     time.Time
	OldestItem  time.Time
	NewestItem  time.Time
}

// CreateCustomAtomFeed creates a custom Atom feed structure with enhanced features
func (fg *FeedGenerator) CreateCustomAtomFeed(posts []RedditPost) (string, error) {
	now := time.Now()

	// Collect URLs for concurrent OpenGraph fetching
	urls := make([]string, 0, len(posts))
	for _, post := range posts {
		if post.Data.URL != "" {
			urls = append(urls, post.Data.URL)
		}
	}

	// Fetch OpenGraph data concurrently
	var ogData map[string]*OpenGraphData
	if fg.ogFetcher != nil {
		slog.Info("Fetching OpenGraph data for custom Atom feed", "url_count", len(urls))
		ogData = fg.ogFetcher.FetchConcurrentOpenGraph(urls)
	}

	var atom strings.Builder
	atom.WriteString(`<?xml version="1.0" encoding="UTF-8"?>`)
	atom.WriteString(`<feed xmlns="http://www.w3.org/2005/Atom" xmlns:reddit="http://reddit.com/atom/ns">`)
	atom.WriteString(`<title>My Reddit Homepage Feed</title>`)
	atom.WriteString(`<link href="https://www.reddit.com/"/>`)
	atom.WriteString(`<id>https://www.reddit.com/</id>`)
	atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, now.Format(time.RFC3339)))
	atom.WriteString(`<author><name>GoRedditFeedGenerator</name></author>`)
	atom.WriteString(`<subtitle>Filtered Reddit homepage posts with enhanced metadata</subtitle>`)
	atom.WriteString(`<generator uri="https://github.com/your-username/red-rss">Red RSS Generator</generator>`)

	for _, post := range posts {
		atom.WriteString(`<entry>`)
		atom.WriteString(fmt.Sprintf(`<title>%s</title>`, escapeXML(post.Data.Title)))

		// Multiple links: Reddit permalink and external URL
		atom.WriteString(fmt.Sprintf(`<link rel="alternate" type="text/html" href="%s"/>`, escapeXML(post.Data.URL)))
		atom.WriteString(fmt.Sprintf(`<link rel="replies" type="text/html" href="https://www.reddit.com%s" title="Reddit Discussion"/>`, escapeXML(post.Data.Permalink)))

		atom.WriteString(fmt.Sprintf(`<id>https://www.reddit.com%s</id>`, escapeXML(post.Data.Permalink)))
		atom.WriteString(fmt.Sprintf(`<updated>%s</updated>`, time.Unix(int64(post.Data.CreatedUTC), 0).Format(time.RFC3339)))
		atom.WriteString(fmt.Sprintf(`<published>%s</published>`, time.Unix(int64(post.Data.CreatedUTC), 0).Format(time.RFC3339)))

		// Enhanced author information
		atom.WriteString(fmt.Sprintf(`<author><name>%s</name><uri>https://www.reddit.com/user/%s</uri></author>`, escapeXML(post.Data.Author), escapeXML(post.Data.Author)))

		// Categories for subreddit
		atom.WriteString(fmt.Sprintf(`<category term="r/%s" label="r/%s"/>`, escapeXML(post.Data.Subreddit), escapeXML(post.Data.Subreddit)))

		// Reddit-specific metadata using custom namespace
		atom.WriteString(fmt.Sprintf(`<reddit:score>%d</reddit:score>`, post.Data.Score))
		atom.WriteString(fmt.Sprintf(`<reddit:comments>%d</reddit:comments>`, post.Data.NumComments))
		atom.WriteString(fmt.Sprintf(`<reddit:subreddit>r/%s</reddit:subreddit>`, escapeXML(post.Data.Subreddit)))

		// Enhanced content with OpenGraph data
		content := fg.buildEnhancedContent(post, ogData)
		atom.WriteString(fmt.Sprintf(`<content type="html">%s</content>`, escapeXML(content)))

		// Summary
		summary := fmt.Sprintf("Score: %d, Comments: %d, Subreddit: r/%s",
			post.Data.Score, post.Data.NumComments, post.Data.Subreddit)
		atom.WriteString(fmt.Sprintf(`<summary>%s</summary>`, escapeXML(summary)))

		// Add thumbnail as enclosure if available from OpenGraph
		if ogData != nil {
			if og, exists := ogData[post.Data.URL]; exists && og != nil && og.Image != "" {
				atom.WriteString(fmt.Sprintf(`<link rel="enclosure" type="image/jpeg" href="%s"/>`, escapeXML(og.Image)))
			}
		}

		atom.WriteString(`</entry>`)
	}

	atom.WriteString(`</feed>`)
	return atom.String(), nil
}

// buildEnhancedContent creates rich HTML content for Atom feeds
func (fg *FeedGenerator) buildEnhancedContent(post RedditPost, ogData map[string]*OpenGraphData) string {
	var content strings.Builder

	// Add basic Reddit metadata
	content.WriteString(fmt.Sprintf(`<div class="reddit-metadata">
<p><strong>Score:</strong> %d | <strong>Comments:</strong> %d | <strong>Subreddit:</strong> <a href="https://www.reddit.com/r/%s">r/%s</a></p>
</div>`, post.Data.Score, post.Data.NumComments, post.Data.Subreddit, post.Data.Subreddit))

	// Add OpenGraph preview if available
	if ogData != nil {
		if og, exists := ogData[post.Data.URL]; exists && og != nil {
			content.WriteString(`<div class="link-preview">`)
			content.WriteString(`<h3>ðŸ”— Link Preview</h3>`)

			if og.Image != "" {
				content.WriteString(fmt.Sprintf(`<img src="%s" alt="Preview image" style="max-width: 200px; height: auto;"/>`, og.Image))
			}

			if og.Title != "" {
				content.WriteString(fmt.Sprintf(`<h4>%s</h4>`, og.Title))
			}

			if og.Description != "" {
				content.WriteString(fmt.Sprintf(`<p>%s</p>`, og.Description))
			}

			if og.SiteName != "" {
				content.WriteString(fmt.Sprintf(`<p><em>Source: %s</em></p>`, og.SiteName))
			}

			content.WriteString(`</div>`)
		}
	}

	// Add links section
	content.WriteString(`<div class="links">`)
	content.WriteString(fmt.Sprintf(`<p><a href="%s">View External Link</a> | <a href="https://www.reddit.com%s">Reddit Discussion</a></p>`, post.Data.URL, post.Data.Permalink))
	content.WriteString(`</div>`)

	return content.String()
}

// escapeXML escapes XML special characters
func escapeXML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	s = strings.ReplaceAll(s, "'", "&apos;")
	return s
}
